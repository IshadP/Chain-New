// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

/**
 * @title SupplyChain
 * @dev A smart contract to track product batches with role-based access control.
 * This version uses contract-generated numeric batch IDs and stores e-way bills on-chain.
 * This version allows for decentralized manufacturer onboarding and removes the single owner admin role.
 */
contract SupplyChain {
    // --- State Variables ---

    uint256 public batchCounter; // Used to generate unique batch IDs

    // Role management
    mapping(address => bool) public isManufacturer;
    mapping(address => bool) public isDistributor;
    mapping(address => bool) public isRetailer;

    // --- Data Structures ---

    enum Status {
        Created, // 0: Batch created by the manufacturer
        InTransit, // 1: Batch has been transferred and is awaiting receipt
        Received // 2: Batch has been received by the current holder
    }

    struct Batch {
        uint256 batchId; // Unique identifier, generated by the contract
        address creator; // Address of the manufacturer who created it
        address currentHolder; // Current owner of the batch
        uint256 quantity; // Number of items in the batch
        string ewaybillNo; // E-way bill number, immutable source of truth
        Status status; // Current status of the batch
        uint256 createdAt; // Timestamp of creation
        uint256 updatedAt; // Timestamp of the last status update
    }

    // Mapping from batch ID to the Batch struct
    mapping(uint256 => Batch) public products;

    // --- Events ---

    event BatchCreated(
        uint256 indexed batchId,
        address indexed creator,
        uint256 quantity,
        string ewaybillNo
    );
    event BatchTransferred(
        uint256 indexed batchId,
        address indexed from,
        address indexed to
    );
    event BatchReceived(uint256 indexed batchId, address indexed receiver);
    event RoleGranted(address indexed user, string role);
    event RoleRevoked(address indexed user, string role);

    // --- Modifiers ---

    modifier onlyManufacturer() {
        require(isManufacturer[msg.sender], "Caller is not a manufacturer");
        _;
    }

    modifier onlyCurrentHolder(uint256 _batchId) {
        require(
            msg.sender == products[_batchId].currentHolder,
            "Caller is not the current holder of the batch"
        );
        _;
    }

    modifier batchExists(uint256 _batchId) {
        require(
            products[_batchId].createdAt != 0,
            "Batch does not exist"
        );
        _;
    }

    // --- Constructor ---

    constructor() {
        batchCounter = 0;
        isManufacturer[msg.sender] = true; // The deployer is the first manufacturer
        emit RoleGranted(msg.sender, "Manufacturer");
    }

    // --- Role Management Functions ---

    function grantManufacturerRole(address _manufacturer) external {
        require(_manufacturer != address(0), "Invalid address");
        isManufacturer[_manufacturer] = true;
        emit RoleGranted(_manufacturer, "Manufacturer");
    }

    function grantDistributorRole(address _distributor) external onlyManufacturer {
        require(_distributor != address(0), "Invalid address");
        isDistributor[_distributor] = true;
        emit RoleGranted(_distributor, "Distributor");
    }

    function revokeDistributorRole(address _distributor) external onlyManufacturer {
        require(_distributor != address(0), "Invalid address");
        isDistributor[_distributor] = false;
        emit RoleRevoked(_distributor, "Distributor");
    }

    function grantRetailerRole(address _retailer) external onlyManufacturer {
        require(_retailer != address(0), "Invalid address");
        isRetailer[_retailer] = true;
        emit RoleGranted(_retailer, "Retailer");
    }

    function revokeRetailerRole(address _retailer) external onlyManufacturer {
        require(_retailer != address(0), "Invalid address");
        isRetailer[_retailer] = false;
        emit RoleRevoked(_retailer, "Retailer");
    }

    // --- Core Functions ---

    /**
     * @dev Creates a new batch of products.
     * Only a manufacturer can call this.
     * The batchId is generated automatically.
     * @param _quantity The number of items in the batch.
     * @param _ewaybillNo The e-way bill number for tracking.
     */
    function createBatch(uint256 _quantity, string memory _ewaybillNo)
        external
        onlyManufacturer
    {
        require(_quantity > 0, "Quantity must be greater than zero");
        require(bytes(_ewaybillNo).length > 0, "E-way bill number cannot be empty");

        batchCounter++;
        uint256 newBatchId = batchCounter;

        products[newBatchId] = Batch({
            batchId: newBatchId,
            creator: msg.sender,
            currentHolder: msg.sender,
            quantity: _quantity,
            ewaybillNo: _ewaybillNo,
            status: Status.Received, // Initially, the manufacturer "holds" the created batch
            createdAt: block.timestamp,
            updatedAt: block.timestamp
        });

        emit BatchCreated(newBatchId, msg.sender, _quantity, _ewaybillNo);
    }

    /**
     * @dev Transfers a batch to a new holder (distributor or retailer).
     * @param _batchId The ID of the batch to transfer.
     * @param _newHolder The address of the new holder.
     */
    function transferBatch(uint256 _batchId, address _newHolder)
        external
        batchExists(_batchId)
        onlyCurrentHolder(_batchId)
    {
        require(_newHolder != address(0), "Invalid new holder address");
        require(
            isDistributor[_newHolder] || isRetailer[_newHolder],
            "New holder must be a distributor or retailer"
        );

        Batch storage batch = products[_batchId];
        require(batch.status == Status.Received, "Batch must be in 'Received' state to be transferred");

        batch.currentHolder = _newHolder;
        batch.status = Status.InTransit;
        batch.updatedAt = block.timestamp;

        emit BatchTransferred(_batchId, msg.sender, _newHolder);
    }

    /**
     * @dev Allows the current holder to mark a batch as received.
     * @param _batchId The ID of the batch being received.
     */
    function receiveBatch(uint256 _batchId)
        external
        batchExists(_batchId)
        onlyCurrentHolder(_batchId)
    {
        Batch storage batch = products[_batchId];
        require(batch.status == Status.InTransit, "Batch is not in transit");

        batch.status = Status.Received;
        batch.updatedAt = block.timestamp;

        emit BatchReceived(_batchId, msg.sender);
    }

    // --- View Functions ---

    /**
     * @dev Returns the total number of batches created.
     */
    function getBatchCount() external view returns (uint256) {
        return batchCounter;
    }

    /**
     * @dev Fetches the details of a specific batch.
     * @param _batchId The ID of the batch.
     * @return The Batch struct.
     */
    function getBatch(uint256 _batchId)
        external
        view
        batchExists(_batchId)
        returns (Batch memory)
    {
        return products[_batchId];
    }
}